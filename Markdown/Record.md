### CF1801G

* 前后缀很好做，跨越的话 ~~首先可以胡出一个根号做法~~ 可以扫的时候把询问挂在反串 acam 上，合并贡献，子树询问.

### CF2055E

* Part 1
	如果钦定顺序，则答案为 $\sum a +\max\left( \max \left(\left(\sum\limits_{p\le i}a_p \right)-preb_{i-1}\right),0\right)$
* Part 2
	定义 $c_i = \left(\sum\limits_{p\le i}a_p \right)-preb_{i-1}$
	如果没有要求 $c = \max(c,0)$，可以贪心
	
* Part 3
	其实这个要求是在忽悠你! 按照 $2$ 中的做法直接贪并正确处理贡献

* 特殊情况的贪心是对的

### CF2057F

* 改变的位置只有 $O(\log V)$ 个，于是可以扫描线求出每个长度的不同 $m$ 的代价，共 $O(n \log V)$ 个，塞入 `multiset`，查询时二分并在 $O(\log V)$ 个 `multiset` 中询问代价

### CF2062E2

* 考虑如果一个状态不合法会怎么样. 显然此时删掉该点对应的子树后可以得到剩下的大于当前 $w$ 的节点对应一颗扫把，于是预处理出每一个扫把，然后处理贡献.

* 博弈的必胜位置不好求解的情况下可以考虑去关注必败的局面的性质，求解必败局面

### CF2062F

* $\max(a_i+b_j,a_j+b_i)$ 转化为关于 和/差 除以 $2$ 的绝对值式子，和转差

* 遇到 $\max(a_i+b_j,a_j+b_i)$ 可以转化到 $f(x_i)+f(y_j)+\max(x_i-y_j,y_i-x_j)$

### QOJ 6661

* 首先我们可以建立一个 $n \rightarrow 2 \log n$ 的映射
* 即 $w = u \oplus v$ 则答案为 $2^{\text{highbit}(w)+1} + (v \land 2^{(\text{highbit}(w))})$
* 这样迭代 $5$ 遍
* 优化时就发现只用处理 $\text{popcnt} = \frac{n}{2}$ 的情况，这样可以收敛到 $4$ 通过 $3$ 次操作
* 最后 $2$ 次拿一个 `std::set` 去处理一下 $left$ 和 $right$ 就可以了 

### QOJ 8672

* 扫描线右端点，维护每个询问的答案并塞到 FHQ 上，每次对 $key \in [l_i,r_i]$ 的 $key$ 值 $+1$

* 扫描线可以直接维护答案的变化

### QOJ 8673

* 起点终点双向按边 dijkstra，访问到另一端访问过的节点后停止，此时只有至多 $1$ 条边未被访问 ，可以证明复杂度正确

* 随机图的最短路树等生成树高度都是 $O(\log n)$ 可以乱做
* 对于这种深度不大的题目可以考虑使用双向搜索的思想 QwQ
* 随机图双端 dij 的期望访问点数是 $O(\sqrt n)$ 的

### xyd 19366

* 定义 $f(i,j)$ 表示 $i$ 级抽卡至少 $j$ 级的数量，$g(i,j)$ 去计数，转移容斥
* 注意到 $g$ 的系数确定，所以去从终点开始倒推优化复杂度.

* 多起点单终点这一类的问题的优化也可以隐式地用在 DP 优化上

### xyd 19367

* subtask $2$ 倒序处理（有拓扑序），然后正解的一种做法是二分将点插入拓扑序

* 处理关于在子树节点集合的问题时从叶到根处理会方便很多

### CF1483F

* 容易发现对于每个串 $s_i$ 合法的对 $(i,j)$ 上界是 $O(|s_i|)$ 个
* 于是我们考虑先预处理出可能成为答案的 $O(\sum|s_i|)$ 个 $(i,j)$ 对然后去重
* 去重这一步需要转计数，即对于串 $s$，备选串 $s_i$ 合法当且仅当 $s_i$ 在 $s$ 中的出现次数 $f_i$ $=$ $s_i$ 在 $s$ 中的 **作为备选串且不被其他备选串覆盖** 的出现次数 $g_i$

* 可行性问题可以通过答案的性质转化为计数问题


### Kattis GuessingGame2

* [[Guessing Game Solution]]

* 通信题一定要考虑你给的方案能不能存储更多信息去优化，整体结构上的东西也可以存

### xyd 19373

* 有下面的结论之后 DP + Lagrange 插值优化

* 大小为 $a_1 \dots a_n$ 的连通块合并为一棵树的方案数为 $\prod a_i \left(\sum a_i\right)^k$.
* 关于值域的答案为多项式的 dp 可以 lagrange 插值求解


### CF2061G

* 答案是 $\lfloor \frac{(n+1)}{3} \rfloor$，构造方案考虑构造一条同色链 $a_1 \cdots a_k$，和多个异色三元环 $(u_i,v_i,w_i)$，每个点属于其中一种，容易证明答案合法

### CF2061F2

* 区间合法的充要条件 (F1)，DP 计算 $f_i$ 表示 $i$ 不动的代价，然后转移下标不同奇偶性 + 到 $i$ 的区间合法，维护合法区间，sgt 转移

### CF2066A

* 询问最大的和最小的

### CF2066B

* 只用判断加 $0$ 合不合法

### CF2066C

* 定义 $f(i,w)$ 表示 $2$ 个相同且为 $x$，第 $3$ 个为 $pre_i \oplus w$

* 对于每个 $i$， $f(i)$ 只有 $O(1)$ 个位置发生改变，`std::map` 或哈希表维护

### CF2066D2

* 从 $1 \dots n$ 去 DP，而不是从 $n\dots 1$

* 顺序正反都可以入手的题，不妨两个方向都试一下

### CF2066E

* 较为暴力的去考虑充要条件，发现关键位置只有 $O(\log n)$ 个，然后 SGT 维护

### xyd 19443

* 以某个数生成序列可以考虑处理原数 $x$ 的每一位的贡献

### xyd 19445

* $n = 2^k$ 的时候可以考虑拆位
* 形如 $\text{popcnt(x)} = \frac b 2$ 的二进制数在构造时可能比较有用 $\rightarrow$ \[KTSC\] 魔法师

### xyd 19446

* 遇到双变量的东西可以考虑去改单变量去优化

### xyd 19459

* 可以通过给定的信息 ($x \in S_i$) 确定 $x$ $\longrightarrow$ 包含 $x$ 的 $S_i$ 集合唯一

### CF1906C

* 交互构造 "被询问" 的东西时可以考虑构造影响答案的位置的数量很少的方案以确定询问的信息

### CF1906I

* 性质: Top 序为 $p_1 \dots p_n \Rightarrow \forall i \in [1, n - 1] (p_i,p_{i+1}) \in G$

### CF1481F

* 答案下界易得的题目不妨考虑去构造答案上界

### CF1487F

* 没有什么启发

### CF1500E

* 没有什么启发

### CF1427F

* 可以取出一个连续区间可以看成取出 $[L,R]$ 左右括号对，然后删除中间的所有.
