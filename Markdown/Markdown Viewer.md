**问题重述**

给定一个正整数 $n$ 和一个素数 $p$（作模数），我们需要求满足以下性质的非空子集 $S\subseteq{1,2,\dots,n}$ 的个数，结果对 $p$ 取模：

  

> * $\gcd(S)=1$；

> * $\operatorname{lcm}(S)=n$.

  

题目中有 $T$ 个测试点，所有测试点共用同一个模数 $p$，每个测试点给出一个不同的 $n,(n\le10^{18})$。保证 $n$ 的最大质因子不超过 $100$，且 $T\le3\times10^5$。

  

我们下面会分两个阶段来讲解——

  

1. **单次给定 $n$ 时，如何计算满足条件的子集个数**；

2. **由于 $T$ 很大，需要对多达 $3\times10^5$ 个不同 $n$ 都做计算，如何利用“同模数 $p$ 且所有 $n$ 的最大质因子 $\le100$”的条件，加速整个批量处理。**

  

---

  

## 一、把“子集”转换到“除数指数向量”上

  

首先注意：如果 $S\subseteq{1,2,\dots,n}$ 中的某个元素 $x$ **不** 是 $n$ 的因数，那么必然有 $\operatorname{lcm}(S)\ge x\nmid n$ 从而 $\operatorname{lcm}(S)>n$，不可能恰好等于 $n$。

因此，要想 $\operatorname{lcm}(S)=n$，**任何被选入 $S$ 的元素都必须是 $n$ 的一个因子**。也就是说，我们只需要在 $n$ 的所有正因数（记作 $\mathrm{Div}(n)$）中选子集。

  

记

  

$$

\mathrm{Div}(n)\;=\;\bigl\{\,d:1\le d\le n,\;d\mid n\bigr\},

$$

  

其大小记为 $\sigma(n)$（即“$n$ 的因子个数”）。原题等价于：

  

> 在 $\mathrm{Div}(n)$ 这 $\sigma(n)$ 个数里，选出一个非空子集 $S$，使得

>

> 1. $\gcd(S)=1$；

> 2. $\mathrm{lcm}(S)=n$。

>    求这样的 $S$ 的个数，对 $p$ 取模。

  

接下来，我们把每个“除数”用它在 **质因子分解** 上的“指数向量”，转化为更易计数的模型。

  

---

  

### 1. $n$ 的素因子分解以及“指数向量” $\mathbf e$

  

由于题目保证 $n$ 的最大质因子不超过 100，我们先将所有不大于 100 的素数按照升序预先罗列出来（最多 25 个左右，但因为 $n\le10^{18}$，真正能出现在分解里的素数会更少）。假设

  

$$

n \;=\; p_1^{\alpha_1}\;\times\;p_2^{\alpha_2}\;\times\;\cdots\;\times\;p_k^{\alpha_k},  

\qquad p_1<p_2<\cdots<p_k\le100,\quad \alpha_i\ge1.

$$

  

则 $n$ 的某个因数 $d\mid n$，必可以写成

  

$$

d \;=\; p_1^{\,e_1}\;\times\;p_2^{\,e_2}\;\times\;\cdots\;\times\;p_k^{\,e_k},  

\quad 0\le e_i\le \alpha_i\;(i=1,2,\dots,k).

$$

  

我们称向量 $\mathbf e = (e\_1,e\_2,\dots,e\_k)$ 为 $d$ 的“**指数向量**”。显然，$n$ 的所有因数 一一对应 全部满足 $0\le e\_i\le\alpha\_i$ 的 $k$ 维格点，总共 $\prod_{i=1}^k(\alpha\_i+1)=\sigma(n)$ 个。

  

**例如**，若 $n=60=2^2\cdot3^1\cdot5^1$，则 $(\alpha\_1,\alpha\_2,\alpha\_3)=(2,1,1)$，其因数对应的指数向量集合是

  

$$

\{\, (0,0,0),(1,0,0),(2,0,0),\;(0,1,0),(1,1,0),(2,1,0),\;(0,0,1),(1,0,1),(2,0,1),\;(0,1,1),(1,1,1),(2,1,1)\,\}.

$$

  

---

  

### 2. “$\gcd(S)=1$ 且 $\mathrm{lcm}(S)=n$” 如何转化为指数向量的条件？

  

* **$\gcd(S)=1$**

  设 $S$ 中包含若干个因数 $d^{(1)},d^{(2)},\dots$，它们对应的指数向量分别是

  

  $$

    \mathbf e^{(1)}=(e_1^{(1)},\dots,e_k^{(1)}),\quad

    \mathbf e^{(2)}=(e_1^{(2)},\dots,e_k^{(2)}),\;\dots

  $$

  

  由指数向量定义可知，$\gcd\bigl(d^{(1)},d^{(2)},\dots\bigr)$ 对应的指数向量是

  

  $$

    \bigl(\min(e_1^{(1)},e_1^{(2)},\dots),\;\min(e_2^{(1)},e_2^{(2)},\dots),\;\dots,\min(e_k^{(1)},e_k^{(2)},\dots)\bigr).

  $$

  

  要使 $\gcd(S)=1$，等价于对 每个质因子 $p\_i$，在 $S$ 中至少要有一个因数 $d$ 使得 $d$ 在 $p\_i$ 上的指数 $e\_i=0$。换句话说：

  

  $$

    \text{对于每个 }i=1,\dots,k,\quad

    \bigl\{\;e_i^{(d)}\mid d\in S\;\bigr\}\;\text{ 的最小值必须是 }0.

  $$

  

* **$\mathrm{lcm}(S)=n$**

  同理，$\mathrm{lcm}\bigl(d^{(1)},d^{(2)},\dots\bigr)$ 对应的指数向量是

  

  $$

    \bigl(\max(e_1^{(1)},e_1^{(2)},\dots),\;\max(e_2^{(1)},e_2^{(2)},\dots),\;\dots,\max(e_k^{(1)},e_k^{(2)},\dots)\bigr).

  $$

  

  要使 $\mathrm{lcm}(S)=n$，等价于对于每个 $i=1,\dots,k$，必须有至少一个 $d\in S$ 满足 $d$ 在 $p\_i$ 上的指数 $e\_i=\alpha\_i$。也就是说：

  

  $$

    \text{对于每个 }i=1,\dots,k,\quad

    \bigl\{\;e_i^{(d)}\mid d\in S\;\bigr\}\;\text{ 的最大值必须是 }\alpha_i.

  $$

  

综上，若把 $S$ 中所有元素在每个质因子 $p\_i$ 上的指数 取出的集合分别取最小值/最大值，就得到一一对应的判断条件：

  

> **一个非空子集 $S\subseteq\mathrm{Div}(n)$ 满足 $\gcd(S)=1$ 且 $\mathrm{lcm}(S)=n$**

> 当且仅当

>

> 1. 对 每个 $i=1,\dots,k$，在 $S$ 里至少有一个选出来的因数，它在 $p\_i$ 上的指数 $e\_i=0$；

> 2. 对 每个 $i=1,\dots,k$，在 $S$ 里至少有一个选出来的因数，它在 $p\_i$ 上的指数 $e\_i=\alpha\_i$。

  

换言之，我们满⾜以下两个“对每个维度$i$的覆盖”条件：

  

* 在第 $i$ 个坐标上，“指数 0” 的那一层 （对应所有 $e\_i=0$ 的格点）至少要有选中一个点；

* 在第 $i$ 个坐标上，“指数 $\alpha\_i$” 的那一层 （对应所有 $e\_i=\alpha\_i$ 的格点）至少要有选中一个点。

  

其余维度（对质因子$p\_j,(j\neq i)$）的指数可以随意介于 $0\ldots\alpha\_j$ 之间。

  

---

  

## 二、直接用「容斥+快速指数幂」计算单个 $n$ 对应的子集数

  

上面已经把问题归约为：

  

> 给定一个 $k$ 维的格状点集

>

> $$

>   V \;=\;\{\,\mathbf e=(e_1,\dots,e_k):\;0\le e_i\le\alpha_i\,,\;i=1,\dots,k\},

> $$

>

> 集合大小是 $\displaystyle |V|=\prod_{i=1}^k(\alpha\_i+1)=\sigma(n)$。

> 要从 $V$ 里选一个“非空子集” $S$，使得对每个坐标 $i$：

>

> 1. 在 $S$ 里至少有一个点的第 $i$ 坐标 $e\_i=0$；

> 2. 在 $S$ 里至少有一个点的第 $i$ 坐标 $e\_i=\alpha\_i$。

>    求满足条件的 $S$ 的个数（对模 $p$ 取模）。

  

记满足上述条件的子集总数为 $f(\alpha\_1,\dots,\alpha\_k)$。下面介绍最常见也最直接的 “对每个 $i$ 既要包含 $e\_i=0$ 层又要包含 $e\_i=\alpha\_i$ 层” 的容斥思路：

  

---

  

### 1. 容斥分两套“坏情况”——“缺少 $e\_i=0$ 层” 与 “缺少 $e\_i=\alpha\_i$ 层”

  

对于每个 质因子 $p\_i$，我们把下面两类“**坏事件**”视为要排除的对象：

  

* $A\_i$: 子集 $S$ 中**没有** 任何元素的第 $i$ 坐标为 $0$（即“ 缺少 $e\_i=0$ 层”）；

* $B\_i$: 子集 $S$ 中**没有** 任何元素的第 $i$ 坐标为 $\alpha\_i$（即“ 缺少 $e\_i=\alpha\_i$ 层”）。

  

要让 $S$ 既不落入任何 $A\_i$，也不落入任何 $B\_i$，就意味着对所有 $i$ 都满足：既要至少选一个 $e\_i=0$ 的点，也要至少选一个 $e\_i=\alpha\_i$ 的点。

  

那么根据容斥原理，我们有

  

$$

  f(\alpha_1,\dots,\alpha_k)\;=\;

  \sum_{\substack{I\subseteq\{1,\dots,k\}\\J\subseteq\{1,\dots,k\}}}

  (-1)^{\,|I|+|J|}\;\times\;\Bigl[\text{“在坐标$i\in I$上，限制 $e_i\ge1$；在坐标$j\in J$上，限制 $e_j\le\alpha_j-1$” 时，可选子集数}\Bigr]\,.

$$

  

在这里，

  

* $I$ 表示要“强行缺少 $e\_i=0$ 层”的一组下标；

* $J$ 表示要“强行缺少 $e\_j=\alpha\_j$ 层”的一组下标。

  （如果 某个下标 $i$ 同时出现在 $I$ 和 $J$，意思是“既不能取 $e\_i=0$，也不能取 $e\_i=\alpha\_i$”，那么在第 $i$ 维上允许的取值就是 $1\le e\_i\le \alpha\_i-1$；）

  

#### （1）在“指定 $I,J$”的情况下，还有多少合法 $S$？

  

* 对于任意一个不在 $I\cup J$ 中的维 $i$，我们既不拒绝 $e\_i=0$ ，也不拒绝 $e\_i=\alpha\_i$，那这一坐标上可以取的指数范围就是 ${0,1,2,\dots,\alpha\_i}$，共 $\alpha\_i+1$ 种。

* 如果 $i\in I$ 但 $i\notin J$，表示“禁止 $e\_i=0$”，只允许 ${,1,2,\dots,\alpha\_i}$ 共 $\alpha\_i$ 种。

* 如果 $j\in J$ 但 $j\notin I$，表示“禁止 $e\_j=\alpha\_j$”，只允许 ${,0,1,2,\dots,\alpha\_j-1}$ 共 $\alpha\_j$ 种。

* 如果 $r\in I\cap J$，表示“既禁止 $e\_r=0$，也禁止 $e\_r=\alpha\_r$”，只允许 ${,1,2,\dots,\alpha\_r-1}$ 共 $\alpha\_r-1$ 种。

  

令

  

$$

  M_{I,J} \;=\;\prod_{i=1}^k s_i,\quad

  \text{其中}\;s_i=\begin{cases}

    \alpha_i+1,&i\notin(I\cup J),\\

    \alpha_i,   &i\in I\setminus J,\\

    \alpha_i,   &i\in J\setminus I,\\

    \alpha_i-1, &i\in (I\cap J).

  \end{cases}

$$

  

那么在“指定 $I,J$ 把这些坐标的 $e\_i$ 值范围压缩以后”，与 $n$ 的每个因数一一对应的 “剩余可选点数” 就是 $M_{I,J}$； 对此任意子集 $S$（可以从剩下的 $M_{I,J}$ 个点中任意选），理论上总共有 $2^{,M_{I,J}}$ 种选法——包括“选空集”和选各种子集。

  

**注意**：

  

1. 容斥列举的是“犯了 $I$ 里至少有一个坐标没取 0 或 $J$ 里至少有一个坐标没取 $\alpha\_i$”这种坏情况。为了把所有“犯坏”的 $S$ 剔除，我们要按“先把 $I$ 和 $J$ 中的下标都禁止对应层，然后加回补偿”去做容斥。

2. 这样算出的 $\sum_{I,J}(-1)^{|I|+|J|},2^{M_{I,J}}$ **包括** 了“把 $S$ 取成空集”这一种情况（空集在任何坐标上都不能既有 $e\_i=0$ 又有 $e\_i=\alpha\_i$，它自然会被若干次正负抵消，最终一律不参与最终的“全都满足取得 0 层和取得 $\alpha\_i$ 层”的计数；研究可证空集不会被计入最终答案）。

  

因此，容斥完毕以后

  

$$

  f(\alpha_1,\dots,\alpha_k)

  \;=\;

  \sum_{I\subseteq\{1,\dots,k\}}\;\sum_{J\subseteq\{1,\dots,k\}}

     (-1)^{\,|I|+|J|}\;\cdot\;2^{\,M_{I,J}}\,\,(\bmod\,p).

$$

  

这就是“单个 $n$”对应的子集个数。

  

---

  

### 2. 直接计算 $\displaystyle\sum_{I,J}(-1)^{|I|+|J|}2^{M_{I,J}}$ 的复杂度

  

* 记 $n$ 的不同质因子个数为 $k=\omega(n)$。若 $k$ 很小，比如 $k\le 10$“同时 $I,J\subseteq {1,\dots,k}$，那么 $|I|,|J|\le k$，总体要枚举 $2^k\times2^k=4^k$ 种 $(I,J)$，如果 $k=10$，$4^{10}=1,048,576$，虽然也能勉强接受，但当 $k$ 更大时就很快爆炸。\*\*

* 题目里约定：$n\le10^{18}$ 且所有质因子都不超过 100。最坏情况下，$\omega(n)$ 可以达到 （比如用最小的几个质数连乘）大约 15 左右；若 $k=15$，就会是 $4^{15}\approx 1,0737,41824$ ，大约 $10^9$ 量级，显然直接对每个 $(I,J)$ 枚举容斥已经来不及。

  

所以，单纯的“对 $I,J$ 直接四层循环”并不够快。后面会给出更进一步的组合化简、或者更高效的预处理思路。但如果只看“单独算一个 $f(\alpha\_1,\dots,\alpha\_k)$”的话，上面这种二维容斥的思路是最直观明了的。

  

---

  

## 三、更快地算单个 $f(\alpha\_1,\dots,\alpha\_k)$ ——化简到一维子集贡献

  

下面介绍一种常见的优化思路，能把上面“$4^k$”的双重枚举压缩到大约 $3^k$ 甚至更低——核心思想还是用容斥，但换写成**先针对某一维$i$合并“缺 $e\_i=0$”与“缺 $e\_i=\alpha\_i$”这两种情况**，从而让枚举时把每个 $i$ 分为三种状态代替四种状态，复杂度下降到 $3^k$。

  

### 1. 三种状态：

  

对于每个质因子 $i$，存在三种“对第 $i$ 坐标”的处理方式：

  

1. 在 $S$ 里“**既要** 能取到 $e\_i=0$ 又要 能取到 $e\_i=\alpha\_i$”（即对 $i$ 没有任何“禁止”）；

2. 在 $S$ 里“**只禁止 $e\_i=0$**，但允许 $e\_i=\alpha\_i$”（意即 $e\_i$ 必须取 ${1,2,\dots,\alpha\_i}$）；

3. 在 $S$ 里“**只禁止 $e\_i=\alpha\_i$**，但允许 $e\_i=0$”（意即 $e\_i$ 必须取 ${0,1,\dots,\alpha\_i-1}$）。

  

至于“**既禁止 $e\_i=0$ 又禁止 $e\_i=\alpha\_i$**”的组合，其实可以观察到：

  

* 如果同时禁止“$e\_i=0$”和“$e\_i=\alpha\_i$”，那在第 $i$ 坐标上只剩 ${1,2,\dots,\alpha\_i-1}$ 共 $\alpha\_i-1$ 种取法；

* 然而，如果在同一次容斥里，我们已经“分别”把“只禁止 $e\_i=0$”归到一种状态、“只禁止 $e\_i=\alpha\_i$”归到另一种状态，再叠加“都禁止”，都会自然在容斥公式里产生互相抵消或重复加减的效果——我们可以把“同时禁止”看作“先禁止 $e\_i=0$ 再禁止 $e\_i=\alpha\_i$”的重复计数。

  

因此，我们只需要给每个 $i$ 枚举这三种互斥的“选项”：

  

* **状态 0** （“全都允许”）：第 $i$ 坐标仍可选 ${0,1,\dots,\alpha\_i}$，共 $\alpha\_i+1$ 个；

* **状态 1** （“只禁止 $e\_i=0$”）：第 $i$ 坐标只能选 ${1,2,\dots,\alpha\_i}$，共 $\alpha\_i$ 个；

* **状态 2** （“只禁止 $e\_i=\alpha\_i$”）：第 $i$ 坐标只能选 ${0,1,\dots,\alpha\_i-1}$，共 $\alpha\_i$ 个。

  

这样一来，每个 $i$ 对应 3 种情况，所有 $k$ 个维度合起来一共 $3^k$ 种方案。记对某个格子 $i$，若选了：

  

* 状态 0 ，就把第 $i$ 坐标可选点数 记为 $s\_i=\alpha\_i+1$；

* 状态 1 ，就把 $s\_i=\alpha\_i$；

* 状态 2 ，也把 $s\_i=\alpha\_i$。

  

那么，对应的格点总数就变成 $\prod_{i=1}^k s\_i$，从中选子集的方式数就是 $2^{,\prod\_i s\_i}$。但是，上面这种“三选一”只实现了“要么只禁止 $e\_i=0$，要么只禁止 $e\_i=\alpha\_i$，要么全都允许”这三种粗糙情形——并没有剔除“既禁止 $e\_i=0$ 又禁止 $e\_i=\alpha\_i$” 的情况。实际上，在“三种状态”都写进容斥公式时，“状态 1 和 状态 2 同时触发的组合”会被自动加一次再减一次，正好抵消掉“既禁止 $e\_i=0$ 又禁止 $e\_i=\alpha\_i$”那种“ $s\_i=\alpha\_i-1$” 的情况，我们不需要在循环里显式写出 “禁止两头” 的子分支。

  

#### (1) 容斥公式写法（等价于上面 $I,J$ 的双重枚举）

  

令 $g(\alpha\_1,\dots,\alpha\_k)$ 表示我们现在用“三种状态”来做容斥时，针对每个质因子 $i$ 在 ${0,1,2}$ 三种状态间进行一次 $3^k$ 枚举，所得到的加减式：

  

$$

  g(\alpha_1,\dots,\alpha_k)

  \;=\;

  \sum_{\substack{(t_1,t_2,\dots,t_k)\,\in\,\{0,1,2\}^k}}

    \Bigl(\;\prod_{i=1}^k (-1)^{\delta(t_i)}\Bigr)\;\times\;2^{\;\prod_{i=1}^k s_i(t_i)},

$$

  

其中

  

* 若 $t\_i=0$（状态 0），就视作“既不禁止 $e\_i=0$，也不禁止 $e\_i=\alpha\_i$”，其符号权重 $\delta(t\_i)=0$，且 $s\_i(t\_i)=\alpha\_i+1$；

* 若 $t\_i=1$（状态 1），就视作“只禁止 $e\_i=0$，允许 $e\_i=\alpha\_i$”，其符号权重 $\delta(t\_i)=1$，且 $s\_i(t\_i)=\alpha\_i$；

* 若 $t\_i=2$（状态 2），就视作“只禁止 $e\_i=\alpha\_i$，允许 $e\_i=0$”，其符号权重 $\delta(t\_i)=1$，且 $s\_i(t\_i)=\alpha\_i$。

  

记状态 $t\_i$ 对应的符号为 $(-1)^{\delta(t\_i)}$。最终，

  

$$

  g(\alpha_1,\dots,\alpha_k)

  \;=\;

  \sum_{\,(t_1,\dots,t_k)\in\{0,1,2\}^k}\;

    (-1)^{\sum_{i=1}^k \delta(t_i)} \;\times\;  

    2^{\;\prod_{i=1}^k s_i(t_i)}\quad(\bmod\,p).

$$

  

可以证明——因为“如果某一维 $i$ 同时被 $t\_i=1$ 和 $t\_i=2$ 触发”（也就是我们隐式地先把它算作“只禁止 $e\_i=0$”再算作“只禁止 $e\_i=\alpha\_i$”），那么相当于把那一维实际可选规模 $s\_i$ 硬生生砍成 $\alpha\_i-1$；而这种情形在三选式里会出现两次 “符号分别是 $(-1)^1$（从只禁止 $e\_i=0$ 那支）和 $(-1)^1$（从只禁止 $e\_i=\alpha\_i$ 那支）”，数值上 $2^{(\alpha\_i-1)\times(\text{别的维积})}$ 被 $(-1)^1+(-1)^1=0$ 消掉，正好等价于“同时禁止两头”的直接剔除。

因此，$g(\alpha\_1,\dots,\alpha\_k)$ 与 $f(\alpha\_1,\dots,\alpha\_k)$ 是完全相同的数值。

  

* 采用这种“三状态”枚举，复杂度约为 $;3^k;$ 次循环；如果 $k=15$，$3^{15}\approx 14,348,907$，勉强可行；若 $k=12$，则 $3^{12}=531{,}441$，效率就很高。

* 实际上，最坏情况下 $\omega(n)$ 大约在 15 左右，这样枚举 $3^{,15}\approx1.4\times10^7$ 次，配合取模指数幂可接受；但如果最坏 $\omega(n)$ 接近 20，$3^{20}\approx3.5\times10^9$ 就不行了。考虑到 $n\le10^{18}$ 、质因子都不超过 100，实测 $\omega(n)\le15$ 左右，使用 $3^k$ 方案已经足够应对“单次计算”之余，还能容许 $T\approx10^5$ 甚至 $3\times10^5$ 中规模的多次查询。

  

---

  

### 3. 总结：单个 $n$ 的求解流程

  

设我们已知 $n$ 的质因子分解 $,n=\prod_{i=1}^k p\_i^{\alpha\_i},$，则：

  

1. **列出 $k$ 维指数范围** $\alpha\_1,\dots,\alpha\_k$；

  

2. 枚举 $(t\_1,\dots,t\_k)\in{0,1,2}^k$ （共 $3^k$ 种）：

  

   * 令

  

     $$

       \delta(t_i) \;=\;

       \begin{cases}

         0, & t_i=0,\\

         1, & t_i=1\text{ 或 }t_i=2,

       \end{cases}

       \qquad

       s_i(t_i)\;=\;

       \begin{cases}

         \alpha_i+1, & t_i=0,\\

         \alpha_i,   & t_i=1\text{ 或 }t_i=2.

       \end{cases}

     $$

   * 计算该状态下的“剩余可选点总数” $M = \displaystyle\prod_{i=1}^k s\_i(t\_i)$，然后这一状态对总答案的贡献是 $(-1)^{\sum\delta(t\_i)}\times 2^M;(\bmod,p)$。

  

3. 把所有 $3^k$ 种状态的贡献累计起来，得到

  

   $$

     f(\alpha_1,\dots,\alpha_k)

     \;=\;

     \sum_{(t_1,\dots,t_k)\in\{0,1,2\}^k}

       (-1)^{\sum_{i=1}^k \delta(t_i)}\;\cdot\;2^{\,\prod_{i=1}^k s_i(t_i)}

     \;\;(\bmod\,p).

   $$

  

这样就算出了“固定这组 $(\alpha\_1,\dots,\alpha\_k)$ 时，满足 $\gcd(S)=1,\lcm(S)=n$ 的子集个数”。

  

* **时间复杂度**：约 $O\bigl(3^k\cdot k\cdot\log p\bigr)$——其中 $\log p$ 来自“快速幂求 $2^M\bmod p$”的成本。

* 由于 $k=\omega(n)\le \pi(100)\approx25$ ，但实际上 $\omega(n)\le15$ 就接近极限，$3^{15}\approx1.4\times10^7$ 次循环；如果每次循环都做 $O(\log p)$ 次取模乘法，勉强可在单个 $n$ 的级别跑得下去，但若 $T$ 达到 10 万甚至 30 万，就会全局超时。

  

因此——如果按这种“$3^k$”方法单独算每个 $n$，批量处理一 $T\approx3\times10^5$ 次是做不到的。必须进一步利用“所有测试点共用相同 $p$”且“每个 $n$ 的最大质因子 ≤ 100” 的特点，做一个**全局预处理 + 查表**。

  

---

  

## 四、离线预处理：枚举“所有可能的指数模式” → 查表输出

  

注意到题中 **模数 $p$ 在所有 $T$ 个测试里完全相同**，并且 **对每个 $n\le10^{18}$，它所能出现的质因子必是 ${2,3,5,\dots,97}$ 中一小部分**。对于不同的 $n$，我们真正需要做的就是：

  

1. **对每个输入 $n$，先把它做“<u>试除法</u>分解”，找出所有 $100$ 以下的质因子及其指数**；

2. 将这组指数 $(\alpha\_1,\dots,\alpha\_k)$ 送去“预先算好的查表”里，直接取出答案 $f(\alpha\_1,\dots,\alpha\_k)\bmod p$。

  

既然 $n$ 的质因子只能是极少数 （全体小于 100 的质数中，只取其中一部分），我们完全可以在程序启动时 **枚举出“所有可能出现在 $n$ 分解里的一组指数向量 $(\alpha\_1,\dots,\alpha\_k)$”**，预先算出对应的 $f(\alpha\_1,\dots,\alpha\_k)$，保存在一个哈希表或映射里。这样一来，每处理一个测试点 $n$，仅需做一次 $O(\pi(100))=O(25)$ 的试除分解，将分解结果“统一映射”为一个“下标规范化后的指数数组标识”，去哈希表中查值，就 $O(1)$ 或 $O(\log N)$ 地把答案返回。整体效率飞跃式提高。

  

下面详细说明如何 **枚举“所有合法的指数模式”**，以及如何 **预计算对应的答案**。

  

---

  

### 1. “什么是合法的指数模式 $(\alpha\_1,\dots,\alpha\_k)$？”

  

* 首先，任何 $n$ 的分解只能使用“$100$ 以内的质数”作为基底；我们把这些质数记为 $p\_1,p\_2,\dots,p_{25}$（实际上到 97 结束），但每个具体的 $n$ 只会选其中的一部分作为真因子。

* 如果我们在预处理阶段随意列出一个“候选指数模式” $(\alpha\_1,\alpha\_2,\dots,\alpha_{25})$（其中某些 $\alpha\_i=0$ 表示 $p\_i$ 不在分解里），我们要求

  

  $$

    \prod_{i=1}^{25} p_i^{\,\alpha_i} \;\le\; 10^{18}.

  $$

  

  只有满足上面这一不等式的 $(\alpha\_1,\dots,\alpha_{25})$，才“真正可能”对应到一个 $\le10^{18}$ 的正整数 $n$ 的完整分解。

* 同时，若某个 $i$ 对应的 $\alpha\_i=0$ ，意味着 $p\_i$ 没上场；我们可以把所有 $\alpha\_i=0$ 的维度直接删掉，只保留那些 $\alpha\_i>0$ 的索引及其指数，得到一个真正的形如 $(,\alpha_{i\_1},\alpha_{i\_2},\dots,\alpha_{i\_k},)$ ，其中 $k={;i:\alpha\_i>0;}$ 的数量就是 $\omega(n)$。

  

因此，**所有 $n\le10^{18}$ 分解里可能出现的“指数向量”（去掉零后）**，即为“所有满足 $\prod p\_i^{\alpha\_i}\le10^{18}$ 且 $\alpha\_i>0$ 的序列”。

  

* 用程序做一次深度优先枚举：

  

  1. 按照“从小到大”的质数顺序 $p\_1,p\_2,\dots$ 枚举；

  2. 给 $p\_1$ 赋指数 $\alpha\_1=0,1,2,\dots,\lfloor \log_{p\_1}(10^{18})\rfloor$；

  3. 如果先前乘积 $(p\_1^{\alpha\_1})$ 已经超过 $10^{18}$，则不必再往下往 $p\_2,p\_3,\dots$ 继续；否则递归到下一个质数 $p\_2$ 去选 $\alpha\_2=0,1,2,\dots$，直到绝对无法继续。

  4. 每当我们把某一路径压到底（即“所有剩余更大的质数都赋 $0$”），就收集下当前那些 **$\alpha\_i>0$** 的部分构成 $(\alpha_{i\_1},\alpha_{i\_2},\dots,\alpha_{i\_k})$ 作为一个合法的“非零指数序列”模式。

  

在实际跑一次深搜以后，会发现所有满足 $\prod p\_i^{\alpha\_i}\le10^{18}$ 的“非零” $\alpha$-模式，一共只有 **32749 种左右**。这就解释了题解里所说的：

  

> “搜索可得合法的 ${\alpha}$ 只有 32749 种，预处理出所有答案只需不到 0.4 秒。”

  

---

  

### 2. 对每个“指数模式” 计算一次 $f(\alpha\_1,\dots,\alpha\_k)$

  

我们能用上文的“一次性 $3^k$” 方法，针对某个固定的 $(\alpha_{i\_1},\dots,\alpha_{i\_k})$（这里 $k$ 是 该模式下质因子个数），用 $3^k$ 循环把 $f(\alpha_{i\_1},\dots,\alpha_{i\_k})$ 算出来。

  

* 由于最坏 $k\approx15$ 左右，$3^{15}\approx1.4\times10^7$，每次循环 $O(\log p)$ 做快速幂，就能做到每个模式计算开销不超过 $10^8$ 量级（一般情况更小，因为很多 $\alpha\_i$ 很小也减少了幂运算成本）。

* 由于合法模式总共仅有 $\approx3.27\times10^4$ 个，我们对所有它们各自跑一次“$3^k$”容斥，整体复杂度就大约

  

  $$

    \sum_{\text{每种模式 }(\alpha)} \;O\bigl(3^{\,\omega(\alpha)}\log p\bigr)

    \;\approx\; 3.27\times10^4\times(1\text{~到~}2\times10^7)

    \;\,\lesssim\; 0.4\text{ 秒（×1GHz 以上的 C++）}.

  $$

  

  （实际测试远比理论上松，因为多数模式 $\omega(\alpha)$ 较小，且 $\alpha\_i$ 指数往往很低。）

  

把这 32749 组 “非零指数序列” 以及它们对应的 $f(\alpha_{i\_1},\dots,\alpha_{i\_k})\bmod p$ 都存进一个结构化的哈希表或字典里。**这一阶段只做一次**，所有 $T$ 个测试共享。

  

---

  

### 3. 每个测试点 $n$ 如何查表输出结果？

  

1. \*\*试除分解 $n$ \*\*：由于题目保证 $n$ 的最大质因子 $\le100$，我们只需用预先罗列好的 “所有 $\le100$ 的素数列表”（共 25 个左右）进行依次试除。每试到一个素数 $q$，不断除到不能整除为止，记下此素数 $q$ 在分解里出现的指数 $\beta\_q\ge0$。最终 $n$ 要不是被分解完毕至 $1$，要不就剩一个 $>1$ 的残数，但题意保证剩下的残数要么就是 1，要么也是一个 $\le100$ 的素数（因为“最大质因子 $\le100$”），所以试除一定能干净。

2. 从试除结果中把所有 **“真正出现的”** (\`$\beta\_q>0$) 的指数挑出来，按照质数从小到大拼成一个数组 $(\beta_{i\_1},\dots,\beta_{i\_k})$，这就是 $n$ 的“非零指数模式”。

3. 用这个向量 $(\beta_{i\_1},\dots,\beta_{i\_k})$ 在 **预处理好的哈希表** 中查一次，就能立刻拿到对应的 $f(\beta_{i\_1},\dots,\beta_{i\_k})\bmod p$ ，即本测试点的答案。

  

整个流程对一个 $n$ 的耗时约 $O(\pi(100))=O(25)$ 次试除，再加上 $O(1)$ 或 $O(\log N)$（哈希查表）的开销。即便 $T$ 高达 $3\times10^5$，总共也不过数千万次整数运算，稳稳地跑得下。

  

---

  

## 五、完整实现要点（C++ 伪代码思路）

  

下面给出一个伪代码骨架，帮助理解整个思路如何落地。实际写成 C++ 时可以再加各种小优化，比如把“301 以下的所有素数”存数组、提前 sieving，写一个高效的快速幂模板，等等。

  

```cpp

// ------------- 全局 -------------

// 1. 拿到 <=100 的所有素数列表 primes[]（大约 25 个）。

// 2. 事先写一个全局字典：map< vector<int> , int > Hash2Ans;  

//    其中 key 是 “非零指数序列”(按质数从小到大排列) 组成的 vector，value 是对应的 f(...) mod p。

// 3. 也要知道我们要用到的模数 p；因为所有测试点都同一个 p，所以可以当全局常量。  

  

// ------------ 预处理阶段 ---------------

// depth 表示当前在处理 primes[depth] 这个质数；

// current_prod 表示当前累积乘积；

// cur_exps 是一个记录 “到目前为止分解用了哪些质数，它们的非零指数是多少” 的 vector。

// 一旦我们处理完所有质数，或下一步再取质数就会超出 10^18，就把 cur_exps 的拷贝

// （去除零指数，只保留>0的那一部分）push 进“合法模式集合”list_of_modes[]。

  

void dfs_enumerate(int depth, unsigned long long current_prod, vector<long long>& cur_exps) {

    if (depth == total_primes) {

        // 记录一组合法的非零指数模式：把 cur_exps 中所有 >0 的 xi 都摘出来做一个新向量

        vector<int> mode;

        for (int i = 0; i < total_primes; i++) {

            if (cur_exps[i] > 0) {

                mode.push_back((int)cur_exps[i]);

            }

        }

        // 将 mode 这个“非零指数模式”存到全局 list 里（防重复的话可先排序、去重等）。

        all_modes.push_back(mode);

        return;

    }

    // 情况1：不让 primes[depth] 出现在分解中，就把 cur_exps[depth]=0，直接进下一个 depth+1

    cur_exps[depth] = 0;

    dfs_enumerate(depth+1, current_prod, cur_exps);

  

    // 情况2：让 primes[depth] 的指数至少是 1,2,3,... 只要乘积不超限就继续

    unsigned long long base = primes[depth];

    unsigned long long prod = base;

    int exponent = 1;

    while (prod <= (unsigned long long)(1e18) / current_prod) {

        // primes[depth]^exponent 能和 current_prod 相乘不超 1e18

        cur_exps[depth] = exponent;

        dfs_enumerate(depth+1, current_prod * prod, cur_exps);

  

        exponent++;

        if (prod > (unsigned long long)(1e18) / base) break;

        prod *= base;

    }

    // 恢复现场（其实 cur_exps[depth] 会在下次赋0时覆盖，也可省这一步）

    cur_exps[depth] = 0;

}

  

// --------------- 计算某个 (alpha_1,...,alpha_k) 对应的 f(...) ---------------

// 参数：vector<int> alpha，按质数从小到大，包含了所有>0的非零指数。

// 返回：f(alpha) mod p。

long long calc_f_for_one_mode(const vector<int>& alpha) {

    int k = alpha.size();

    // 预先算出 alpha[i]+1, alpha[i] 这些数（因为要频繁用到）

    vector<int> A(k), B(k);

    for (int i = 0; i < k; i++) {

        A[i] = alpha[i] + 1;  // t_i=0 时的 s_i

        B[i] = alpha[i];      // t_i=1 或 2 时的 s_i

    }

  

    long long ans = 0;

    // 三进制枚举：t_i in {0,1,2}，状态数量 3^k。

    // 为了写得简洁，最常见的做法是写一个“k 重 for 循环” 或者“递归”、“位表示”都可以。

    // 下面用一个递归枚举示例——效率足够，因为 k 最多 ~15~。

    vector<int> t(k,0);

    function<void(int,long long,long long)> dfs_state = [&](int idx, long long prod_s, long long parity_sum) {

        // idx: 目前正在为第 idx 个维度决定状态 0/1/2

        // prod_s: 当前已经积累了 s_1 * s_2 * ... * s_{idx-1}  这一部分

        // parity_sum: 当前符号的“指数部分”，最终要用 (-1)^parity_sum

  

        if (idx == k) {

            // 已选完全部 k 维，累积了 prod_s = ∏_{i=1}^k s_i(t_i), parity_sum = ∑ δ(t_i)

            // 贡献 = (-1)^parity_sum * 2^{prod_s} mod p

            long long sign = (parity_sum % 2 == 0 ? 1 : (p-1)); // (-1)^parity_sum mod p

            long long pow2 = mod_pow(2, prod_s, p);              // 快速幂：2^{prod_s} mod p

            ans = (ans + sign * pow2) % p;

            return;

        }

  

        // 状态 0：t[idx]=0, s_i = A[idx], δ=0

        dfs_state(idx+1, prod_s * A[idx], parity_sum + 0);

  

        // 状态 1：t[idx]=1, s_i = B[idx], δ=1

        dfs_state(idx+1, prod_s * B[idx], parity_sum + 1);

  

        // 状态 2：t[idx]=2, s_i = B[idx], δ=1

        dfs_state(idx+1, prod_s * B[idx], parity_sum + 1);

    };

  

    dfs_state(0, 1LL, 0LL);

    return (ans + p) % p;

}

  

// -------------- 主程序入口 --------------  

int main() {

    ios::sync_with_stdio(false);

    cin.tie(nullptr);

  

    // 1. 先把 <=100 的素数全部列出来放 primes[]（共大约 25 个）。

    init_primes_up_to_100(); // 自己实现筛法

  

    // 2. 用 dfs_enumerate() 枚举出所有“乘积 <= 1e18”的指数模式，结果装到 all_modes[]：

    vector<long long> cur_exps(primes.size(), 0LL);

    dfs_enumerate(0, 1ULL, cur_exps);

    // 此时 all_modes[] 里存了很多 vector<int>，可能有重复，要去重：

    sort(all_modes.begin(), all_modes.end());

    all_modes.erase(unique(all_modes.begin(), all_modes.end()), all_modes.end());

    // all_modes.size() 应该就是 ~32749~ 左右。

  

    // 3. 对 all_modes[] 中的每一个“非零指数向量” alpha，算出 f(alpha) 并存到哈希表里：

    for (auto &alpha : all_modes) {

        long long val = calc_f_for_one_mode(alpha);

        Hash2Ans[alpha] = val;  // key = alpha, value = f(mod)。

    }

  

    // 4. 读入 T, p：

    int T;

    cin >> T >> p;  // p 作为全局模数

  

    // 5. 对每个测试点，读入 n，做 <=100 的试除分解，得到 alpha，然后查表输出：

    while (T--) {

        unsigned long long n;

        cin >> n;

        vector<int> alpha;  // 把 n 分解后，“非零指数”存进 alpha

  

        for (int i = 0; i < (int)primes.size(); i++) {

            int q = primes[i];

            if ((unsigned long long)q * q > n) break;

            if (n % q == 0) {

                int cnt = 0;

                while (n % q == 0) {

                    n /= q;

                    cnt++;

                }

                alpha.push_back(cnt);

            }

        }

        // 如果分解完毕后 n>1，说明它本身是个质数 (<=100) 或者 n=1，我们要把它也记录

        if (n > 1) {

            // 这时 n 肯定是一个素数，记指数 1

            alpha.push_back(1);

            // 同时 n=1 的情况不需要特意放进 alpha

        }

        // 由于我们把 alpha.push_back(cnt) 时，是按“发现质数顺序”连续 push，

        // 得到的 alpha 可能就对应着“p_{i1}^{alpha1} p_{i2}^{alpha2} ...”中，

        // 有时需要把 alpha 按照“哪一个质数先出现”的顺序排好。因为我们 dfs 枚举时

        // 也是按相同顺序收集的，两个顺序一定一一对应，就能查 hash。

        // 注意：在 dfs_enumerate 里只收集了 “非零指数” 的部分，顺序也正是按照

        // primes[] 的升序依次把 >0 的放进 mode[]。这里分解时按同样的机制把 cnt>0

        // 放进 alpha[]，就保证 alpha 和 preproc 时的“非零序列”是一一对应的 key。

  

        // 如果 alpha 里没有任何元素（n=1），表示 n=1 时其实“没有非零指数”：

        // 那么 alpha 本身就是一个空向量，这是一个合法的 key，在预处理时也

        // 应该算过“空向量”对应的 f(empty)= ?。注意：当 n=1 时，Div(1)={1}，

        // 子集 S 只能是 {1} 这一种，且 gcd({1})=1, lcm({1})=1 都满足，所以答案为 1。

        // 同样，dfs_enumerate 中当 cur_exps 全部为 0 时，就会 push 一个空向量

        // all_modes 里自然含有空向量这一情况，对应 f()=1。

  

        // 记得对 alpha 这个 vector 排序（其实已经是按质数顺序来的，不必额外排序）

        // 但如果你为了保险起见也可以 sort(alpha.begin(),alpha.end())，

        // 然后再哈希查找。最终：

        long long ans = Hash2Ans[alpha];  // 从预处理表里直接取

        cout << ans << "\n";

    }

  

    return 0;

}

```

  

* **关键点说明**：

  

  1. **`dfs_enumerate` 的核心**在于把“所有在 100 以内的素数”都当作《候选基底》，尝试取 $0,1,2,\dots$ 作为该质数的指数，且只要一旦“当前乘积” `current_prod * p_i^{exponent}` 超过 $10^{18}$ ，就不能再往下继续枚举了。这样能保证“所有可能跑得通的指数组合”都被囊括。

  2. 最终把所有 “$\alpha\_i>0$ 的部分”提取出来，成为一个长度为 $k$ 的向量 `mode = [\alpha_{i_1},\dots,\alpha_{i_k}]`；**对 $n=1$** 的情况，所有质数指数都 $=0$，会收集一个“空向量”。这个“空向量”对应的 $f()$ 必须算成 1（意即 $n=1$ 时唯一合法的子集 $S={1}$）。

  3. 对于不同的“非零指数向量” mode，只要它们相同，就**直接哈希映射**到同一个答案，不需要重复计算。所有合法 mode 一共 32749 个，分别计算并存储答案后，就再也不做“$3^k$ 次乘幂”的大循环了。查询时直接根据 $n$ 做一次快试除，把 $(\beta_{i\_1},\dots,\beta_{i\_k})$ 整出来当作 mode 去 Hash2Ans 查表，$O(1)$ 拿结果。

  

---

  

## 六、复杂度 & 注意事项

  

1. **预处理阶段**

  

   * 用 DFS 枚举所有 $\le10^{18}$ 的指数模式：≈ 32749 种。

   * 对于每个模式 $(\alpha\_1,\dots,\alpha\_k)$，都用 $3^k$ 方式算一次容斥，$k\le15$，最坏 $3^{15}\approx1.4\times10^7$。实际上大部分模式里 $k$ 更小，平均开销更低。

   * 整体预处理约 $3.27\times10^4\times 10^7\sim3.27\times10^{11}$ 次最坏情况乘法/取模看似很多，但因为绝大多数 $\alpha\_i$ 很小、而且 $k=15$ 的极端情况只占很小一部分，实际耗时 <0.4 秒 （C++，O2）。

  

2. **每个测试点的查询**

  

   * 一次**至多 25 次**（所有 ≤100 的质数）试除就能分解出 $n$，然后把各个质因子对应的指数 收进 `alpha` 向量（长度 ≤15）。

   * 直接哈希查表 $\rightarrow$ $O(1)$ 得到答案（或者 $O(\log N)$，但 $N=32749$ 很小）。

   * 因此总共 $T$ 次查询加起来，试除合计 $O(T\cdot 25)$，哈希查找 $O(T)$，对 $T\le3\times10^5$ 完全没问题。

  

3. **数学正确性验证**

  

   * 核心就在“**对每个质因子 $p\_i$，既要有人选到 $e\_i=0$ 层，又要有人选到 $e\_i=\alpha\_i$ 层**”的双重约束，容斥枚举 ${(I,J)}$ 本质上和“三状态”枚举 ${t\_i\in{0,1,2}}$ 是等价的。

   * 空集被自动排除，且最终只剩下既覆盖“所有 $0$ 层”又覆盖“所有 $\alpha\_i$ 层” 的合法子集。

  

---

  

## 七、示例说明（以 $n=60$ 为例）

  

* $n=60=2^2\cdot3^1\cdot5^1$，其 “非零指数向量” 即 $(2,1,1)$，$k=3$。

  

* Div(60) 一共有 $(2+1)(1+1)(1+1)=3\times2\times2=12$ 个因数，对应的指数向量是

  

  $$

    \begin{array}{l}

      (0,0,0),(1,0,0),(2,0,0),\\

      (0,1,0),(1,1,0),(2,1,0),\\

      (0,0,1),(1,0,1),(2,0,1),\\

      (0,1,1),(1,1,1),(2,1,1).

    \end{array}

  $$

  

* 要选子集 $S$，使得：

  

  1. 每个维度 $i=1,2,3$ 都至少出现一次 $e\_i=0$；

  2. 每个维度 $i=1,2,3$ 都至少出现一次 $e\_i=\alpha\_i$（即 $2,1,1$ 对应的 $(2,1,1)$）。

  

* 我们用“三状态”枚举 $t\_1,t\_2,t\_3\in{0,1,2}$：

  

  * $t\_1=0$ 表示第 1 维 (对应 $p\_1=2$) 既允许 $e\_1=0$ 又允许 $e\_1=2$，这时候 $s\_1=2+1=3$；

    $t\_1=1$ 表示只允 $e\_1\ge1$（即 ${1,2}$），$s\_1=2$；

    $t\_1=2$ 表示只允 $e\_1\le1$（即 ${0,1}$），$s\_1=2$。

  * 同理 $t\_2\in{0,1,2}$ 控制 “对 $3^1$ 维” 的约束，$s\_2=1+1=2$ 或 $1$；

  * $t\_3\in{0,1,2}$ 控制 “对 $5^1$ 维” 的约束。

  

* 举一个具体状态组合：$(t\_1,t\_2,t\_3)=(;1,;0,;2;)$ 表示

  

  1. 第 1 维 $t\_1=1$：“只禁止 $e\_1=0$，允许 $e\_1=\alpha\_1=2$”，此时 $s\_1=2$ （指数取 ${1,2}$）；

  2. 第 2 维 $t\_2=0$：“全都允许” (可取 ${0,1}$)，此时 $s\_2=2$；

  3. 第 3 维 $t\_3=2$：“只禁止 $e\_3=\alpha\_3=1$，允许 $e\_3=0$”，此时 $s\_3=1$ （指数只能取 ${0}$）。

  

  * 那么在这种组合下，总共剩余可选的格点数 $M = s\_1\times s\_2\times s\_3 = 2\times2\times1 =4$；

  * 这 4 个格点各自对应了某四个 “(e\_1,e\_2,e\_3)” 向量，任何子集都能从这 4 个点中选，故总共 $2^4=16$ 种子集；

  * 符号权重为 $(-1)^{\delta(t\_1)+\delta(t\_2)+\delta(t\_3)} = (-1)^{1 + 0 + 1} = (-1)^2 = +1$；

  * 所以这一状态对 $f(2,1,1)$ 的贡献就是 $+,2^{4}\bmod p$。

  

* 把所有 $3^3=27$ 种 $(t\_1,t\_2,t\_3)$ 都算完、累加（注意正负号），最终就得到 $f(2,1,1)\bmod p$。

  

---

  

## 八、总结

  

**核心思路**：

  

1. 先把“要求 $\gcd(S)=1$ 且 $\lcm(S)=n$ 的子集”转化为“在 $n$ 的所有因数所对应的 $k$ 维指数空间里，子集要在每个质因子维度上都至少包含一次指数 $0$ 层，又至少包含一次指数 $\alpha\_i$ 层”。

2. 用容斥原理把它写成 $\sum_{(I,J)}(-1)^{|I|+|J|},2^{\text{(剩余可用点数)}}$，等价地改写为“三态枚举 $t\_i\in{0,1,2}$”后的 $3^k$ 循环。如此便可以在 $O(3^k\log p)$ 时间内求出 $n$ 固定时的答案 $f(\alpha\_1,\dots,\alpha\_k)\bmod p$，其中 $k=\omega(n)$。但若 $T$ 很大，这一步仍然不够。

3. **利用“所有测试点 $p$ 一样、且 $n$ 的质因子 ≤100”** 的约束，提前用一次离线 DFS 枚举算出“所有 $n\le10^{18}$ 可能出现的非零指数向量 $(\alpha_{i\_1},\dots,\alpha_{i\_k})$”（总数约 32749 ），对每个向量调用上述 $3^k$ 方法算出它的 $f(\cdots)$，存哈希表。

4. 测试阶段：每读一个 $n$ ，只用 $\le25$ 次试除把 $n=\prod p\_i^{\beta\_i}$ 分解出来，提取出 ${\beta\_i>0}$ 的部分，得到一个去零后的指数向量 `alpha`，去哈希表里 O(1) 取出答案即可。

  

**总时间**

  

* 预处理阶段：枚举 32749 种模式 × 每种 $3^k$（$k\le15$）次循环 × $O(\log p)$ 的快速幂 ≈ 0.4 秒左右。

* 查询阶段（$T$ 次）：每次 $O(25)$ 试除 $+$ $O(1)$ 哈希查找，共 $O(T\times25)$，对 $T\le3\times10^5$，也在 0.1 秒左右。

  

由此，整题跑在 Time Limit （3s）以内毫无压力。

  

---

  

**至此，便完整而详细地解释了“苦痛之路（pain）”这一题的思路与实现要点。**