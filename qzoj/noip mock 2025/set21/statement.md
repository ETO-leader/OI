# End Time

 Time Limit: 1000 ms  Memory Limit: 512 MB 

## 题目背景

[End Time](https://www.bilibili.com/video/BV1at411F7nS/)

Every "END" is a new "BEGINNING"

## 题目描述

你有 $n$ 个点排成一个环，第 $i$ 个点和第 $i \bmod n + 1$ 个点间有一条长度为 $1$ 的边。废机油偷偷选了两个点 $x,y$，然后在 $x,y$ 之间加了一条长度为 $1$ 的边。你每次可以选择两个点 $(u,v)$，废机油将会从 $u$ 开始推箱子到 $v$，并且他会告诉你箱子走的最短路径距离。由于废机油推太多次箱子后会获得 $72$ 分，所以他最多只能推 $40$ 次箱子。你需要在推 $40$ 次箱子之内找到废机油偷偷选的两个点 $x,y$。

**交互库为非自适应的**，即答案的两个点是初始选好的，而非随着你的询问而更新。

## 交互格式

你不需要实现，也不应该实现主函数。

你可以调用的交互库函数：

`int Query(int x, int y);`

当 $1\le x,y \le n$ 时，会返回 $x,y$ 在图上的最短路。否则会返回 $-1$（也会计入调用次数）。

你需要实现的交互库函数：

`pair<int, int> push_box(int n);`

给定参数 $n$，返回你猜的初始两个点，可以以任意顺序返回。保证每组数据只会调用一次。

## 输入格式

样例交互库输入格式：

一行三个正整数 $T,n,seed$。表示数据组数，最大的 $n$ 和随机种子。

## 输出格式

样例交互库输出格式：

- `Wrong Answer, you got 72 pts.` 表示你返回的答案错误。

- `Operations Limit Exceeded, you got 8 pts.` 表示你调用了超过 $40$ 次 `Query`。

- `Accepted, the boxes can be pushed!` 表示你的答案正确，并且调用交互库次数 $\le 40$。

## 输入输出样例 #1

### 输入 #1

```
1 4 20240301
```

### 输出 #1

```
Query(2, 4): 2
Query(1, 3): 1
ok 1 3
```

## 说明/提示

**本题使用子任务捆绑**。

对于所有测试数据，保证 $1\le T \le 10^3,4 \le n \le 10^9$。**保证 $x,y$ 不是相邻的两点**。

| 子任务编号 | $n\le$ | 分值 |   特殊性质   |
| :--------: | :----: | :--: | :----------: |
|    $1$     |  $9$   | $20$ |      无      |
|    $2$     | $1000$ | $40$ |      无      |
|    $3$     | $10^9$ | $10$ | 保证 $x=y+2$ |
|    $4$     | $10^9$ | $30$ |      无      |



# Oshama Scramble!

 Time Limit: 1000 ms  Memory Limit: 512 MB 

## 题目背景

[牛奶](https://www.bilibili.com/video/BV15s411S7aY/)

每天一杯奶，强壮音游人！

## 题目描述

给定一棵大小为 $n$ 的二叉树，满足小根堆的性质，编号为 $1\sim n$。问有多少个长为 $n$ 的排列 $p$ 使得依次把 $p_1,p_2,\ldots,p_n$ 依次插入斜堆后得到的形态为给定的二叉树。你只需要输出排列个数对 $P$ 取模后的结果。

斜堆的代码如下：

```cpp
void ins(int x, int &u){
    if(!u) return u = x, void();
    if(x < u){
        a[x][0] = u, u = x;
        return;
    }
    swap(a[u][0], a[u][1]);
    ins(x, a[u][0]);
}
```

即，插入一个数 $x$ 时，若 $rt=0$ 或 $x<rt$，就把 $rt$ 当成 $x$ 的左子树且把 $x$ 当成新的根。否则交换根的左右子树，然后递归地插到根的新的左子树中。

**不保证 $P$ 为质数**。

## 输入格式

第一行两个正整数 $n,P$。

接下来 $n$ 行，每行两个整数 $ls_i,rs_i$，表示 $i$ 的左儿子和右儿子，若为 $0$ 则表示空。保证一定构成一棵二叉树，且满足小根堆的性质。

## 输出格式

一行一个整数，表示答案对 $P$ 取模的结果。

## 输入输出样例 #1

### 输入 #1

```
3 5
2 0
3 0
0 0
```

### 输出 #1

```
2
```

## 说明/提示

**本题使用子任务捆绑**。

对于所有的测试数据，保证 $1\le n \le 10^6,2\le P \le 10^9$。

| 子任务编号 | $n\le$ | 分值 |           特殊性质           |
| :--------: | :----: | :--: | :--------------------------: |
|    $1$     |  $10$  | $20$ |              无              |
|    $2$     | $10^6$ | $20$ |      保证所有 $rs_i=0$       |
|    $3$     | $10^6$ | $20$ | 保证给出的二叉树为完全二叉树 |
|    $4$     | $10^6$ | $40$ |              无              |

你绝赞 miss 了。



# 系ぎて

 Time Limit: 1000 ms  Memory Limit: 512 MB 

## 题目背景

[系ぎて](https://www.bilibili.com/video/BV1BK421t78g/)

我治好了抑郁症。

## 题目描述

你有 $n$ 个箱子排成一行，每个箱子有个权值 $a_i$。你要把这行箱子中的若干个推到第二行，推完后定义 $s_1,s_2$ 为这两行的箱子的权值从左到右顺序排列组成的序列。你要使得 $s_1 \le s_2$ 的情况下最小化 $s_2$ 的字典序。问最小的 $s_2$。

定义两个长为 $len_1,len_2$ 的序列 $p_1 < p_2$，当且仅当 $(\exist i\le \min(len_1,len_2),\forall j < i,p_{1,j} = p_{2,j},p_{1,i} < p_{2,i}) \lor (len_1 < len_2 \land \forall i \le len_1,p_{1,i} = p_{2,i})$。

## 输入格式

第一行一个正整数 $T$，表示测试数据个数。

对于每组测试数据：

- 第一行一个正整数 $n$。

- 第二行 $n$ 个正整数 $a_1,a_2,\ldots,a_n$，表示权值序列。

## 输出格式

对于每组测试数据：

- 第一行一个整数 $m$，表示 $|\min s_2|$。

- 第二行 $m$ 个正整数 $s_{2,1},s_{2,2},\ldots,s_{2,m}$。

## 输入输出样例 #1

### 输入 #1

```
5
5
3 1 2 3 2
3
1 1 2
3
3 3 3
5
1 3 1 3 1
5
2 2 1 3 3
```

### 输出 #1

```
1
3
3
1 1 2
2
3 3
3
1 3 1
4
2 1 3 3
```

## 说明/提示

**本题使用子任务捆绑**。

对于所有的测试数据，保证 $1\le a_i \le n \le 2\times 10^4$，$1\le \sum n \le 2\times 10^4$。

| 子任务编号 |     $n\le$     | 分值 |      特殊性质       |
| :--------: | :------------: | :--: | :-----------------: |
|    $1$     |      $20$      | $15$ |         无          |
|    $2$     | $2\times 10^4$ | $10$ | 保证所有 $a_i$ 相等 |
|    $3$     |     $100$      | $25$ |         无          |
|    $4$     |     $500$      | $25$ |         无          |
|    $5$     | $2\times 10^4$ | $25$ |         无          |

welcome to maimaiDX!



# 树上内邻域跳跃

 Time Limit: 4000 ms  Memory Limit: 512 MB 

## 题目描述

给定一棵大小为 $n$ 的有根树，点的编号 $1$ 到 $n$，根节点为 $1$ 号节点。

点 $i$ 有一个二元组 $(dep_i,str_i)$，其中 $dep_i$ 表示 $i$ 到根的距离，$str_i$ 表示从根节点到 $i$ 的简单路径上的所有节点的编号顺次连接组成的一个**字符集为点的编号**的字符串。

定义 $f(x,k)$ 的计算方式如下：

1. 求出 $(x,k)$ 内邻域内的点的编号集合 $S$。

2. 将 $S$ 中的点按照其二元组升序排序（即以 $dep$ 为第一关键字，以 $str$ 的字典序为第二关键字从小到大排序），排序后的点记为 $c_1,c_2,\ldots,c_{|S|}$。

3. $f(x,k)$ 的值即为 $\sum_{i=1}^{|S|-1} \operatorname{Dis}(c_i,c_{i+1})$。

求 $\color{Red}\oplus_{i=1}^{n}((\sum_{j=0}^{n-1}f(i,j))\bmod 2^{32})$ 的值。

定义 $u$ 到 $v$ 的距离，即 $\operatorname{Dis}(u,v)$，为从 $u$ 到 $v$ 的树上唯一简单路径上的边数。

定义 $(u,d)$ 内邻域表示树上 $u$ 子树内（包括 $u$）与 $u$ 的距离 $\le d$ 的点集。

## 输入格式

第一行输入两个整数 $id,n$，其中 $id$ 为子任务编号，和四个非负 int 范围内的整数 $seed,A,B,C$。

选手需要用如下代码生成 $fa$ 数组，表示每个点的父亲。

```
mt19937 g(seed);
fa[1] = 0;
for(int i = 2; i <= n; ++i) {
    int l = max(1, (i - A) / C), r = max(1, (i - B) / C);
    fa[i] = g() % (r - l + 1) + l;
}
```


## 输出格式

一行一个整数表示答案。

### 输入 #1

```
0 7 3 10 1 1
```

### 输出 #1

```
48
```

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/n2a8oiz1.png?x-oss-process=image)

每个点的二元组如下所示（其中 $\mid$ 仅作为字符串中字符的分隔方式）：

| 节点编号 | 二元组                    |
| -------- | ------------------------- |
| $1$      | $(0,1)$                   |
| $2$      | $(1,1 \mid 2)$            |
| $3$      | $(2,1 \mid 3)$            |
| $4$      | $(2,1\mid 2\mid 4)$       |
| $5$      | $(3,1\mid 2\mid 4\mid 5)$ |
| $6$      | $(3,1 \mid 6)$            |
| $7$      | $(4,1\mid 7)$             |

以 $f(1,3)$ 为例，其 $c$ 序列为 $1,2,3,6,7,4,5$，故 $f(1,3)=\operatorname{Dis}(1,2)+\operatorname{Dis}(2,3)+\operatorname{Dis}(3,6)+\operatorname{Dis}(6,7)+\operatorname{Dis}(7,4)+\operatorname{Dis}(4,5)=11$。


**【数据范围】**

**本题使用子任务捆绑**。

对于所有的测试数据，满足 $1\le n\le 6\times 10^6$，$fa_i<i$。

| 子任务编号 | 分值 |      $n≤$      | 树的形态 |
| :--------: | :--: | :------------: | :------: |
|     1      |  5   |     $1000$     |    A     |
|     2      |  5   |     $1000$     |    B     |
|     3      |  5   |     $1000$     |    C     |
|     4      |  5   |    $3×10^4$    |    A     |
|     5      |  5   |    $3×10^4$    |    B     |
|     6      |  5   |    $3×10^4$    |    C     |
|     7      |  10  |    $3×10^4$    |    D     |
|     8      |  20  | $4\times 10^5$ |    D     |
|     9      |  10  | $6\times 10^6$ |    A     |
|     10     |  10  | $6\times 10^6$ |    B     |
|     11     |  5   | $6\times 10^6$ |    C     |
|     12     |  15  | $6\times 10^6$ |    D     |

上表“树的形态”一栏中：
 * A：$A=10^9,B=1,C=1$。

 * B：$A=0,B=0,2\le C$。

 * C：$A=\lfloor\sqrt n\rfloor,B=\lfloor\sqrt n\rfloor,C=1$。

 * D：代表树的形态无特殊限制。

