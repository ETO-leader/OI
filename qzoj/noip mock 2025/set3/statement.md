# Problem A

有一棵包含 $n$ 个结点的未知有根树，顶点从 $1$ 到 $n$ 编号。
 给定任意两点的最近公共祖先编号，试求出树的形态（即每个点的父结点编号），保证有解。

**输入格式**
 第一行：一个整数 $n$，表示树的结点数量。
 接下来 $n$ 行：每行 $n$ 个整数，第 $i$ 行第 $j$ 列的数表示 $i,j$ 两点的最近公共祖先的编号。

**输出格式**
 第一行：$n$ 个整数，第 $i$ 个数表示 $i$ 的父结点的编号，根结点的父结点定义为 $0$。

**样例 1**

输入：

```
5
1 2 2 1 1
2 2 2 2 2
2 2 3 2 2
1 2 2 4 1
1 2 2 1 5
```

输出：

```
2 0 2 1 1
```

**大样例 / 数据范围**
 对于全部数据，$1 \le n \le 1000$。
 对于 $30\%$ 的数据，$n \le 3$；
 对于 $50\%$ 的数据，$n \le 7$；
 对于另外 $20\%$ 的数据，所有结点的深度最大值为 $n$；
 对于另外 $20\%$ 的数据，所有结点的深度最大值为 $2$。
 深度：根结点深度为 $1$，非根结点深度比其父结点深度大 $1$。

------

# Problem B

（后文有一个形式化的题意说明。）

Hiemal（亚纳尔）级异常：项目是由两个或多个相关但不同的异常组成的相互控制的系统。
 Thaumiel（萨麦尔）级异常：被用于收容或抵制其他异常。

Dr.SakuraMiku（这不算角色扮演）在“Keter 任务”中观察到了 $T$ 次异常事件。每一次事件可描述为 $n$ 个 Thaumiel 级“模因”和 $m$ 个 Hiemal 级“逆模因”出现（你不需要知道这是什么），分别从 $1$ 开始编号。对这些异常的不恰当措施可能造成 “VK” 现实重组事件。对于第 $i$ 个“模因”，它可以收容的“逆模因”集合为 $C_i$。已发现 $k$ 个集合，编号为 $S_1 \sim S_k$。任何一个“逆模因”至多属于一个集合。每一个 $S_i$ 都可细分为三个部分，称为 $T_{i,1}, T_{i,2}, T_{i,3}$（可能存在某个 $S_i$ 为空或某个 $T_{i,j}$ 为空的情况）。

该事件的一种收容方式，定义为一个“模因”与“逆模因”之间的对应关系（一个“模因”必须对应其可以收容的一个“逆模因”或不对应任何“逆模因”），满足不同“模因”对应到不同“逆模因”。此时称一个“逆模因”被收容，当且仅当存在一个“模因”对应到它。

该收容方式**有效**，当且仅当任意 $S_i$ 中存在至少 $3$ 个“逆模因”未被收容，且 $T_{i,1}, T_{i,2}, T_{i,3}$ 中至少 $2$ 个集合包含未被收容的“逆模因”。

收容的“逆模因”越多，就越能降低收容失效的风险。现在，Dr.SakuraMiku 想知道一个有效的收容方式最多收容多少个“逆模因”。特别地，若不存在有效的收容方式，输出 “VK”（不含引号）。

**形式化的题面：**
 $T$ 组数据，给定一张二分图，左边有 $n$ 个点，右边有 $m$ 个点，左边第 $i$ 个点连向的右边点集为 $C_i$。同时，有 $k$ 个右边的点的集合 $S_1 \sim S_k$，任意一个右边的点至多属于一个集合 $S$。每个集合 $S_i$ 又被分为三个部分：$T_{i,1}, T_{i,2}, T_{i,3}$。注意此处任何点集都可能为空。你需要找到满足以下条件的最大匹配：任意一个 $S_i$ 中至少 $3$ 个元素没有被匹配到，且 $T_{i,1}, T_{i,2}, T_{i,3}$ 中至少 $2$ 个集合存在未被匹配的元素。特别地，若不存在满足条件的匹配，输出 “VK”（不含引号）。

**输入格式**
 第一行一个正整数 $T$ 表示异常事件个数（即数据组数）；
 以下为 $T$ 组数据：

- 每组数据第一行为三个非负整数 $n, m, k$；
- 以下 $n$ 行，第 $i$ 行开头一个非负整数，表示 $|C_i|$；之后 $|C_i|$ 个正整数，表示左边点 $i$ 对应的右边的点的集合；
- 之后 $m$ 行，每行 $2$ 个非负整数，第 $i$ 行正整数为 $p_i, q_i$，$p_i = 0$ 则表示右侧点 $i$ 不在任何一个 $S$ 中；否则表示 $i \in S_{p_i}$，且 $i \in T_{p_i,q_i}$。

**输出格式**
 $T$ 行，每行一个非负整数表示答案，或字符串 “VK”（不含引号）。

**输入：**

```
1
6 10 2
4 1 2 3 4
5 2 4 5 6 7
5 3 5 7 9 10
6 1 3 5 8 9 10
2 2 7
2 1 10
1 1
2 1
2 1
2 3
2 2
1 2
1 2
1 3
1 2
2 2
```

**输出：**

```
4
```

**数据范围**
 设 $\sum_{i=1}^{n} |C_i| = C$。
 对所有数据点，$1 \le T \le 10$，$1 \le n,m \le 2500$，$1 \le C \le 6000$，$1 \le k \le 800$。保证数据合法。

子任务 1（分值：$10$）
 $1 \le n,m \le 4$，$1 \le C \le 8$。

子任务 2（分值：$20$）
 $k = 0$。

子任务 3（分值：$10$）
 对所有 $S_i$，$1 \le n,m \le 650$，$1 \le C \le 1800$，$|T_{i,1}| = |T_{i,2}| = 2$，$T_{i,3} = \varnothing$，$k \le 5$。

子任务 4（分值：$30$）
 对所有 $S_i$，$|T_{i,1}| = |T_{i,2}| = 2$，$T_{i,3} = \varnothing$。

子任务 5（分值：$30$）
 无特殊限制。

------

# Problem C

SS80194 小朋友极其喜欢序列操作。
 由于一些特殊的原因，他对于 $42$ 以及它的次幂有着特殊的厌恶情绪，即 $(1, 42, 1764, 423, \ldots)$ 被称作坏的数，其他数都称作好的数。

他现在手里有一个长为 $n$ 的序列 $a$（保证序列原来的数全部不是坏的数），他希望你能帮他完成 $q$ 次操作：

- $1\ i$ — 查询 $a_i$；
- $2\ l\ r\ x$ — 将 $a_l \sim a_r$ 赋值为一个好的数 $x$；
- $3\ l\ r\ x$ — 将 $a_l \sim a_r$ 都加上 $x$，只要存在一个 $a_i$ 还是坏的就继续对 $a_l \sim a_r$ 全部加上 $x$。

**样例 1**

输入：

```
6 12
40 1700 7 1672 4 1722
3 2 4 42
1 2
1 3
3 2 6 50
1 2
1 4
1 6
2 3 4 41
3 1 5 1
1 1
1 3
1 5
```

输出：

```
1742
49
1842
1814
1822
43
44
107
```

**数据范围**
 对于 $20\%$ 的数据，$n,q \le 1000$；
 对于 $40\%$ 的数据，$n,q \le 10000$；
 对于 $100\%$ 的数据，$n,q \le 1 \cdot 10^{5}$，$a_i, x \le 10^{9}$。

------

# Problem D

在平面直角坐标系上，有一个足球场，横坐标范围 $[0, X]$，纵坐标范围 $[0, Y]$。
 开始时，球场上站了 $N$ 个球员，坐标分别为 $(x_i, y_i)$。球在开始时 $1$ 号球员的位置上，你希望让这个球到开始时 $N$ 号球员的位置上。

你可以指挥任一球员进行下列某一操作，但某些操作会提升球员的疲劳度。指挥次数不限但应当有明确的先后顺序。已知每个球员有两种状态：控球和没有控球。

你可以指挥**控球**的球员进行如下操作：

- 踢球：在上下左右四个方向中任选一个，并指定一个正整数 $p$，该球员将球朝指定方向踢出恰好 $p$ 个单位。该球员不会移动，且自动停止控球，疲劳度上升 $A \times p + B$。
- 运球：在上下左右四个方向中任选一个，该球员带球，朝指定方向移动 $1$ 个单位。疲劳度上升 $C$。
- 停止控球：该球员的疲劳度不改变。

你可以指挥**没有控球**的球员进行如下操作：

- 移动：在上下左右四个方向中任选一个，该球员朝指定方向移动 $1$ 个单位，疲劳度上升 $C$。
- 控球：如果该球员所在的位置恰好有球，且没有其他球员控球，该球员才能控球。该球员的疲劳度不改变。

球员和球有可能跑出场外，一个位置上可能有多个球员。球员可视作质点，因此球滚动和运球时都不会因为碰到球员而停下。

让球滚到指定位置的过程中，求所有球员上升的疲劳度之和的最小值。

**输入格式**
 第一行两个整数 $X$ $Y$ 用空格分隔。
 第二行三个整数 $A$ $B$ $C$，用空格分隔。
 第三行一个整数 $N$。接下来的 $N$ 行，第 $i$ 行两个整数 $x_i, y_i$，用空格分隔。
 输入的所有数的含义见题目描述。

**输出格式**
 一行，一个整数，表示所有球员上升的疲劳度之和的最小值。

**样例 1**

输入：

```
6 5
1 3 6
3
1 1
0 4
6 5
```

输出：

```
26
```

样例解释：
 最优解如下：

1. 球员 $1$ 把球向上踢出 $3$ 米。疲劳度上升了 $1 \times 3 + 3 = 6$，球移动到 $(1,4)$。
2. 球员 $2$ 向右移动 $1$ 米。疲劳度又上升了 $6$。
3. 球员 $2$ 开始控球。
4. 球员 $2$ 向上运球 $1$ 米。疲劳度又上升了 $6$，球移动到 $(1,5)$。
5. 球员 $2$ 把球向右踢出 $5$ 米，疲劳度上升了 $1 \times 5 + 3 = 8$，球移动到 $(6,5)$。
    此时，疲劳度之和为 $6 + 6 + 6 + 8 = 26$。没有更好的方案。

**样例 2**

输入：

```
4 6
0 5 1000
6
3 1
4 6
3 0
3 0
4 0
0 4
```

输出：

```
2020
```

**样例 3**
 见下发文件，该样例满足 $N \le 1000, A = 0$。

**数据范围**
 本题采用捆绑测试。
 对于所有数据，$1 \le X, Y \le 300$，$0 \le A, B, C \le 10^{9}$，$2 \le N \le 10^{5}$，$0 \le x_i \le X$，$0 \le y_i \le Y$，$(S_1, T_1) \ne (S_N, T_N)$。

子任务 1（分值：$10$）
 $N = 2$。

子任务 2（分值：$30$）
 $N \le 1000, A = 0$。

子任务 3（分值：$60$）
 无特殊限制。